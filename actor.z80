; FHBG GB
; Copyright (C) 2018 NovaSquirrel
;
; This program is free software: you can redistribute it and/or
; modify it under the terms of the GNU General Public License as
; published by the Free Software Foundation; either version 3 of the
; License, or (at your option) any later version.
;
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
; General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;

SECTION "actor", ROM0

;
; 0 Type and direction
; 1 Y velocity low
; 2 Y velocity high
; 3 Y low
; 4 Y high
; 5 X low
; 6 X high
; 7 State
; 8 Timer to reset state
; 9 Variable 1
; A Variable 2
; B Variable 3
; C Pixel position Y
; D Pixel position X
; E
; F
;

actor_type  = 0
actor_vyl   = 1
actor_vyh   = 2
actor_pyl   = 3
actor_pyh   = 4
actor_pxl   = 5
actor_pxh   = 6
actor_state = 7
actor_timer = 8
actor_var1  = 9
actor_var2  = 10
actor_var3  = 11
actor_pixely = 12
actor_pixelx = 13

astate_normal = 0
astate_stunned = 1
astate_paused = 2

actor_size  = 16

; --------------------------------------------

RunActors:
  ld d, actors>>8
  ld e, 0
.loop:
  ld a, [de]
  or a
  call nz, .call

  ld a, e
  add actor_size
  ret z
  ld e, a
  jr .loop

.call:
  add a ; multiply by 2, mask off direction bit
  ld h, ActorPointers>>8
  ld l, a

  ld a, [hl+]
  ld h, [hl]
  ld l, a
  jp hl

; --------------------------------------------

ActorNone:
  ret

ActorBlock:
;  ld hl, actor_pyl
;  add hl, de
;  ldh a, [PlayerPYL]
;  ld [hl+], a
;  ldh a, [PlayerPYH]
;  dec a
;  ld [hl+], a
;  ldh a, [PlayerPXL]
;  ld [hl+], a
;  ldh a, [PlayerPXH]
;  ld [hl], a

  ld a, $10
  call EnemyMoveForward

  call EnemyGravity
  call EnemyDespawnTimer

  ; Get block color
  ld hl, actor_var1
  add hl, de
  ld a, [hl]
  ld b, a

  ld a, $08
  jp DrawActorWithoutFlip


ActorPoof:
  ret

ActorFireball:
  ret

ActorFlames:
  ld a, $1c
  ld b, 0
  jp DrawActor

ActorBottle:
  ret

ActorChip:
  ld a, $0c
  ld b, 0
  jp DrawActorWithoutFlip

ActorKey:
  ld a, $10
  ld b, 0
  jp DrawActorWithoutFlip

ActorPlodder:
  call EnemyFall
  jr nc, .nowalk
  ld a, $10
  call EnemyWalk
  call EnemyAutoBump
.nowalk:

  ld hl, .frames
  call EnemyFourFrameAnimation
  ld b, 0
  call DrawActor
  jp EnemyCommon
.frames:
  db $4c, $50, $54, $50

ActorSneaker:
  call EnemyFall
  jr nc, .nowalk
  ld a, $20
  call EnemyWalk
  call EnemyAutoBump
.nowalk:

  ldh a, [retraces]
  and 4
  add $40
  ld b, 0
  call DrawActor
  jp EnemyCommon

ActorSpinner:
  ld a, $10
  call EnemyFlying

  ; Display the frame
  call .flip_last_frames

  ld hl, .frames
  call EnemyFourFrameAnimation
  ld b, 0
  call DrawActor

  call .flip_last_frames
  jp EnemyCommon

.flip_last_frames:
  ldh a, [retraces]
  and 16
  jp nz, EnemyTurnAround
  ret

.frames:
  db $74, $78, $7c, $78

ActorOwl:
  ldh a, [retraces]
  and 4
  add $58
  ld b, 0
  call DrawActor
  jp EnemyCommon

ActorGeorge:
  ld a, $70
  ld b, 0
  call DrawActor
  jp EnemyCommon

ActorBurger:
  ld a, $20
  call EnemyFlying

  ld a, $48
  ld b, 0
  call DrawActor
  jp EnemyCommon

ActorFireWalk:
  ldh a, [retraces]
  and 4
  add $28
  ld b, 0
  call DrawActor
  jp EnemyCommon

ActorFireJump:
  jp EnemyCommon

ActorBallGuy:
  ld a, $60
  ld b, 0
  call DrawActor
  jp EnemyCommon

ActorBallRoll:
  ld a, $68
  ld b, 0
  call DrawActor
  jp EnemyCommon

ActorThwomp:
  ld a, $64
  ld b, 0
  call DrawActor
  jp EnemyCommon

ActorMine:
  ld a, $6c
  ld b, 0
  call DrawActorWithoutFlip
  jp EnemyCommon

; --------------------------------------------
EnemyFindFree:
  ld hl, actors
.loop:
  ld a, [hl]
  or a
  jr z, .success

  ld a, l
  add 16
  jr z, .fail
  ld l, a
  jr .loop

.success:
  ; Found a slot, so clear it before returning it
  push hl
  push bc
  xor a
  ld b, 16
.fill_loop:
  ld [hl+], a
  dec b
  jr nz, .fill_loop
  pop bc
  pop hl

  scf ; Return success
  ret
.fail:
  or a ; Return failure
  ret  

EnemyDontMoveIfStunned:
  ld hl, actor_state
  add hl, de
  ld a, [hl]
  or a
  ret z
  pop hl ; eat the return address
  ret

EnemyCommon:
  ; Decrease the timer if enemy state isn't neutral
  ld hl, actor_state
  add hl, de
  ld a, [hl+]
  or a
  jr z, .not_stunned ; Normal state
  dec [hl]
  jr nz, .not_stunned
  dec l
  ld [hl], 0
.not_stunned:

; ----------------------

  ; Display off-screen indicator
  ld hl, actor_pixely
  add hl, de
  ld a, [hl+]
  ld b, a    ; B = Y position
  ld c, [hl] ; C = X position
  cp 144+16
  jr nc, .on_screen
  ld a, c
  cp 160+8
  jr c, .on_screen
.off_screen:

  ; Check X position
  ld a, c
  cp 160
  jr c, .no_x
  ld hl, actor_pxh
  add hl, de
  ldh a, [PlayerPXH]
  cp [hl]
  jr nc, .x_left
.x_right:
  ld c, 160+8-8-2
  ld a, [de]
  rla
  jp nc, .on_screen
  jr .no_x
.x_left:
  ld c, 8+2
  ld a, [de]
  rla
  jp c, .on_screen
.no_x:

  ld h, sprites>>8
  ldh a, [oam_ptr]
  ld l, a
  add 4
  ldh [oam_ptr], a

  ld a, b     ; Y
  ld [hl+], a
  ld a, c     ; X
  ld [hl+], a
  ld a, $21   ; tile
  ld [hl+], a

  ld a, [de]  ; Attribute, use direction to calculate it
  rra
  rra
  and OAM_XFLIP
  ld [hl], a
.on_screen:

  ; fall into the next routine
EnemyCollideWithBlocks:
  ; Convert the positions back
  ld hl, actor_pixely
  add hl, de

  ldh a, [CameraPY]
  add [hl]
  ld b, a ; B = non-scrolled pixel Y position

  inc l

  ldh a, [CameraPX]
  add [hl]
  ld c, a ; C = non-scrolled pixel X position

  ; Now look through the list
  ld hl, actors
.loop:
  ld a, [hl]
  and 127
  cp ACTOR_BLOCK
  jr nz, .next
  ; It's a block!
  ; Skip ahead to the block's pixel Y coordinate to test against the enemy's
  ld a, l
  or actor_pixely
  ld l, a

  ; Colliding vertically?
  ldh a, [CameraPY]
  add [hl]
  scf
  sbc b ; Note will subtract n-1
  sbc (16-1)
  ccf
  adc (16+16-1) ;Carry set if overlap
  jr nc, .reset

  inc l

  ; Colliding horizontally?
  ldh a, [CameraPX]
  add [hl]
  scf
  sbc c ; Note will subtract n-1
  sbc (16-1)
  ccf
  adc (16+16-1) ;Carry set if overlap
  jr nc, .reset

  ; Enemy hit by block!
  ld hl, actor_state
  add hl, de
  ld [hl], astate_stunned
  inc l
  ld [hl], 180

  ret
.reset:
  ld a, l
  and $f0
  ld l, a
.next:
  ; next entry
  ld a, l
  add 16
  ld l, a
  jr nz, .loop

  ret

EnemyTurnAround:
  ld a, [de]
  xor 128
  ld [de], a
  ret

EnemyFourFrameAnimation:
  ldh a, [retraces]
  rra
  rra
  rra
  and 3
  add_hl_a
  ld a, [hl] 
  ret

EnemyFlying:
  call EnemyMoveForward
  
  ld hl, actor_pxl
  add hl, de
  ld a, [hl+]
  or a
  ret z
  ld a, [hl]
  cp 15
  ret c

  ; Pick left or right side
  ld [hl], 0
  ; Direction bit unset (right)
  ld a, [de]
  and 127
  ld [de], a
  call get_random_number
  rra
  jr c, .right
  ld [hl], 15
  ; Direction bit set (left)
  ld a, [de]
  or 128
  ld [de], a
.right:

  dec l
  ; Clear PXL
  ld [hl], 0
  dec l

.loop:
  call get_random_number
  and 15
  cp 12
  jr nc, .loop
  add 2

  ld [hl-], a
  xor a

  ld [hl], a

  ; Also pause the enemy for a moment
  ld hl, actor_state
  add hl, de
  ld [hl], astate_paused
  inc l
  ld [hl], 45
  ret

EnemyMoveForward:
  ld c, a
  call EnemyDontMoveIfStunned

  ld b, 0
  ld a, [de]
  rla
  jr nc, .no
  ; Negate C
  ld a, c
  cpl
  inc a
  ld c, a
  ; Negative, so high byte is $ff
  ld b, 255
.no:

  ld hl, actor_pxl
  add hl, de

  ld a, [hl]
  add c
  ld [hl+], a
  ld a, [hl]
  adc b
  ld [hl], a
  ret

EnemyWalk:
  call EnemyMoveForward

  ; When an enemy touches the side of the screen, move them to the top
  ld hl, actor_pxh
  add hl, de
  ld a, [hl]
  cp 15
  jr c, .no_move
  ; Move to the top middle
  ; X position
  ld a, 7
  ld [hl-], a
  ld a, $80
  ld [hl-], a
  ; Clear Y position
  xor a
  ld [hl-], a
  ld [hl-], a

  ; Randomly switch directions
  call get_random_number
  rra
  call c, EnemyTurnAround
.no_move:

  ld hl, actor_pyl
  add hl, de
  ld a, [hl+] ; get middle of sprite Y pos
  add $80
  ld a, [hl+] ; HL = actor X low after this
  adc 0
  add a
  add a
  add a
  add a
  ld b, level_map>>8
  ld c, a

  ; make a decision based on direction
  ld a, [de]
  rla
  jr c, .left
.right:
  ld a, [hl+]
  add $f0
  ld a, [hl-]
  adc 0
  call .test
  ret nc
; Snap
  xor a
  ld [hl], a ; clear PXL
  scf
  ret

.left:
  inc l
  ld a, [hl-]
  call .test
  ret nc
; Snap
  xor a
  ld [hl+], a ; clear PXL
  ld a, [hl]
  inc a
  ld [hl], a ; increment PXH
  scf
  ret

.test:
  or c
  ld c, a
  ld a, [bc]
  call IsSolid
  ccf
  ret

EnemyAutoBump:
  ret nc
  jp EnemyTurnAround

EnemyFall:
  call EnemyGravity

  call EnemyStandingOnSolid
  ret nc

  ld hl, actor_vyl
  add hl, de
  xor a
  ld [hl+], a ; VYL
  ld [hl+], a ; VYH
  ld [hl], a  ; PYL
  scf
  ret

EnemyStandingOnSolid:
  ld hl, actor_vyh
  add hl, de
  ld a, [hl+] ; HL now = Y position, low
  rla
  jr nc, .positive
.no:
  or a
  ret
.positive;
  inc l ; HL now = Y position, high

  push de
  ld d, level_map>>8

  ld c, 0 ; bits for solidity
  ld a, [hl+] ; HL now = X position, low
  inc a ; one tile below
  add a
  add a
  add a
  add a
  ld b, a     ; hold onto it

  ; left
  inc l       ; get X position high
  ld a, [hl-] ; HL now = X position low
  add b
  ld e, a
  ld a, [de]
  call IsSolid
  ccf
  rl c

  ; right
  ld a, [hl+]
  add $f0
  ld a, [hl]
  adc 0
  add b
  ld e, a
  ld a, [de]
  call IsSolid
  ccf
  rl c
  
  pop de

  ; Carry = set if standing on something
  ld a, c
  or a
  jr z, .no
  scf
  ret


EnemyGravity:
  ld hl, actor_vyl
  add hl, de

  ld a, [hl]
  ld c, a
  add 4
  ld [hl+], a
  ld a, [hl]
  ld b, a
  adc 0
  ld [hl+], a

  ; Limit the speed
  ld a, b
  and 128
  jr nz, .GoingUp
  ld a, c
  cp $60
  blt .GoingUp
  ; Correct it
  dec l
  dec l
  ld a, $60
  ld [hl+], a
  inc l
.GoingUp:

  ; Apply gravity
  ld a, [hl]
  add c
  ld [hl+], a
  ld a, [hl]
  adc b
  ld [hl], a
  ret

EnemyDespawnTimer:
  ld hl, actor_timer
  add hl, de
  ld a, [hl]
  dec a
  ld [hl], a
  ret nz
; Clear timer
  xor a
  ld [de], a
  ret

; --------------------------------------------

DrawActorWithoutFlip:
  ; shift B to have zeros for the flip bits
  sla b
DrawActorFlipped:
  ld c, a
  ld a, [de] ; save direction
  push af

  ; Patch in direction bit
  add a
  srl b
  rra
  ld [de], a

  ld a, c
  call DrawActor

  pop af
  ld [de], a ; restore direction
  ret

DrawActor:
  ; Write the four tiles starting from this base tile
  ldh [temp+0], a
  inc a
  ldh [temp+1], a
  inc a
  ldh [temp+2], a
  inc a
  ldh [temp+3], a

  ld a, b
  ldh [temp+5], a ; attributes

  ld a, [de]
  rla
  jr nc, .no_horiz_flip
  hswap [temp+0], [temp+1]
  hswap [temp+2], [temp+3]
  ld a, b
  or OAM_XFLIP
  ldh [temp+5], a
.no_horiz_flip:

  ld hl, actor_state
  add hl, de
  ld a, [hl]
  cp astate_stunned
  jr nz, .no_vert_flip
  hswap [temp+0], [temp+2]
  hswap [temp+1], [temp+3]
  ldh a, [temp+5]
  or OAM_YFLIP
  ldh [temp+5], a
.no_vert_flip:

; --------------------------------
  ; Convert X and Y positions
  ld hl, actor_pyl
  add hl, de

  ldh a, [CameraPY]
  ld c, a
  ld a, [hl+]
  ld b, a
  ld a, [hl+]
  rept 4
    rra
    rr b
  endr
  ld a, b
  add 16
  sub c
  ldh [temp+4], a

  ldh a, [CameraPX]
  ld c, a
  ld a, [hl+]
  ld b, a
  ld a, [hl+]
  rept 4
    rra
    rr b
  endr
  ld a, b
  add 8
  sub c

  push de

  ; Save the pixel coordinates first
  ld hl, actor_pixely
  add hl, de
  ; Now DE is saved so it can be overwritten freely

  ; D = X, E = Y
  ld d, a
  ldh a, [temp+4]
  ld e, a
  ; Cache pixel X and Y
  ld [hl+], a ; Y
  ld [hl], d  ; X
  
  ; Cancel if offscreen
  cp 144+16
  jr nc, .cancel
  ld a, d
  cp 160+8
  jr c, .nocancel
.cancel:
  pop de
  ret
.nocancel:

  ldh a, [temp+5]
  ld b, a ; B = attribute

  ld h, high(sprites)
  ldh a, [oam_ptr]
  ld l, a
; --------------------------------

  ld a, e
  ld [hl+], a ; Y position
  ld a, d
  ld [hl+], a ; X position
  ldh a, [temp+0]
  ld [hl+],a ; set tile number
  ld a, b
  ld [hl+],a ; set attribute

  ld a, e
  ld [hl+], a ; Y position
  ld a, d
  add 8
  ld [hl+], a ; X position
  ldh a, [temp+1]
  ld [hl+],a ; set tile number
  ld a, b
  ld [hl+],a ; set attribute

  ld a, e
  add 8
  ld [hl+], a ; Y position
  ld a, d
  ld [hl+], a ; X position
  ldh a, [temp+2]
  ld [hl+],a ; set tile number
  ld a, b
  ld [hl+],a ; set attribute

  ld a, e
  add 8
  ld [hl+], a ; Y position
  ld a, d
  add 8
  ld [hl+], a ; X position
  ldh a, [temp+3]
  ld [hl+],a ; set tile number
  ld a, b
  ld [hl+],a ; set attribute
skipdraw:

; --------------------------------
  pop de

  ld a, l
  ldh [oam_ptr], a
  ret

; --------------------------------------------
SECTION "actor_pointers", ROM0,ALIGN[8]
ActorPointers:
  dw ActorNone
  dw ActorBlock
  dw ActorPoof
  dw ActorFireball
  dw ActorFlames
  dw ActorBottle
  dw ActorChip
  dw ActorKey
  dw ActorPlodder
  dw ActorSneaker
  dw ActorSpinner
  dw ActorOwl
  dw ActorGeorge
  dw ActorBurger
  dw ActorFireWalk
  dw ActorFireJump
  dw ActorBallGuy
  dw ActorBallRoll
  dw ActorThwomp
  dw ActorMine
