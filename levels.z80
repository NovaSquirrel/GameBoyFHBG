; FHBG GB
; Copyright (C) 2018 NovaSquirrel
;
; This program is free software: you can redistribute it and/or
; modify it under the terms of the GNU General Public License as
; published by the Free Software Foundation; either version 3 of the
; License, or (at your option) any later version.
;
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
; General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;

SECTION "levels", ROM0

; 16-bit number indicating what columns are enemy spawn points

; 0n yx    - single block
; 00 yx    - finished, position is player spawn point
; 01 yx    - checker
; 02 yx    - solid
; 03 yx    - dirt
; 04 yx    - platform
; 05 yx    - fall platform
; 06 yx    - ladder
; 07 yx    - fence
; 08 yx    - grass
; 09 yx    - flower
; 0a yx    - spring
; 0b yx    - lock
; 0c       -
; 0d       -
; 0e       -
; 0f       -

; 1n yx hw - rectangle fill (uses same list as single block)

; 2n yx    - checker vertical
; 3n yx    - solid vertical
; 4n yx    - ladder vert

; 5n yx    - checker horiz
; 6n yx    - solid horiz
; 7n yx    - platform horiz
; 8n yx    - fall platform horiz
; 9n yx    - fence horiz
; An yx    - grass horiz
; Bn yx    - flowers horiz
; Cn       -
; Dn       -
; En       -
; Fn       -

LVL_DONE      = $00 ; single blocks
LVL_EMPTY     = $00
LVL_CHECKER   = $01
LVL_SOLID     = $02
LVL_DIRT      = $03
LVL_PLAT      = $04
LVL_FPLAT     = $05
LVL_LADDER    = $06
LVL_FENCE     = $07
LVL_GRASS     = $08
LVL_FLOWER    = $09
LVL_SPRING    = $0a
LVL_WATER     = $0b

LVL_RECT      = $10 ; OR with the above list

LVL_V_CHECKER = $20
LVL_V_SOLID   = $30
LVL_V_LADDER  = $40

LVL_H_CHECKER = $50
LVL_H_SOLID   = $60
LVL_H_PLAT    = $70
LVL_H_FPLAT   = $80
LVL_H_FENCE   = $90
LVL_H_GRASS   = $A0
LVL_H_FLOWER  = $B0
LVL_H_DIRT    = $C0

  ; level header format:
  ; mm mm ee ee cL
  ; m = map pointer, e = enemy list, c = chips needed, L = enemy limit
LevelHeaders:
  dw map1, SampleEnemyList
  db $35

  dw map2, SampleEnemyList
  db $05

  dw map3, SampleEnemyList
  db $05

  dw map4, SampleEnemyList
  db $a5

  dw map5, SampleEnemyList
  db $a5


SampleEnemyList:
  db ACTOR_PLODDER, ACTOR_PLODDER, ACTOR_PLODDER, ACTOR_PLODDER
  db ACTOR_SNEAKER, ACTOR_SNEAKER, ACTOR_SNEAKER, ACTOR_SNEAKER
  db ACTOR_SPINNER, ACTOR_SPINNER, ACTOR_SPINNER, ACTOR_SPINNER
  db ACTOR_BURGER, ACTOR_BURGER, ACTOR_BURGER, ACTOR_BURGER
  db 0
include "levels/map1.s"
include "levels/map2.s"
include "levels/map3.s"
include "levels/map4.s"
include "levels/map5.s"
include "levels/title.s"

;--------------------------------
; level decompression
;--------------------------------

SingleBlockList: ; for 0x and 1x
  db BLOCK_EMPTY,    BLOCK_CHECKER,       BLOCK_SOLID,  BLOCK_DIRT
  db BLOCK_PLATFORM, BLOCK_FALL_PLATFORM, BLOCK_LADDER, BLOCK_FENCE
  db BLOCK_GRASS,    BLOCK_FLOWER1,       BLOCK_SPRING, BLOCK_WATER

MultiBlockList: ; for all other commands
; vert
  db BLOCK_CHECKER, BLOCK_SOLID, BLOCK_LADDER
; horiz
  db BLOCK_CHECKER, BLOCK_SOLID, BLOCK_PLATFORM, BLOCK_FALL_PLATFORM
  db BLOCK_FENCE,   BLOCK_GRASS, BLOCK_FLOWER1,  BLOCK_DIRT

LoadLevel:
  ; Calculate pointer to the wanted header
  ld h, a
  ; * 5
  add a
  add a
  add h
  ld hl, LevelHeaders
  add_hl_a

  ; Get level map pointer
  ld a, [hl+]
  ld e, a
  ld a, [hl+]
  ld d, a
  push hl
  call DecompressMap
  ; Clear enemy list
  ld hl, actors
  ld c, 0
  call memclear8
  pop hl

  ; Get enemy pointer
  ld a, [hl+]
  ldh [EnemyList+0], a
  ldh [EnemyListStart+0], a
  ld a, [hl+]
  ldh [EnemyList+1], a
  ldh [EnemyListStart+1], a

  ; Get the last byte with chip count and enemy limit
  ld a, [hl]
  and 15
  ld [EnemyLimit], a
  ld a, [hl]
  swap a
  and 15
  ldh [ChipsNeeded], a
  ldh [IsChipLevel], a
  jr z, .NotChipLevel
  ld a, ACTOR_CHIP|128
  ld [actors+0], a
  ld [actors+16], a
.NotChipLevel:
  ret

; Decompresses map DE into RAM
DecompressMap:
  ld hl, level_map
  ld bc, 256
  call memclear
DecompressMapLoop:
  ; Read type
  ld a, [de]
  inc de
  ldh [temp+0], a
  ; Read position
  ld a, [de]
  inc de
  ldh [temp+1], a

  ; HL = pointer to level data
  ld l, a
  ld h, level_map>>8

  push de
  ; Get high byte of command
  ld a, [temp+0]
  or a
  jr z, .exit
  swap a
  and 15
  jr z, .single
  dec a
  jr z, .rectangle
  dec a
  cp 3
  jr nc, .horiz

.vert:
  call .get_multi_count
  call .get_multi_block_list
  ld de, 16
.vertloop:
  ld [hl], a
  add hl, de
  dec c
  jr nz, .vertloop
  jr .done
; ----------------------------------
.horiz:
  call .get_multi_count
  call .get_multi_block_list
.horizloop:
  ld [hl+], a
  dec c
  jr nz, .horizloop
  jr .done
; ----------------------------------
.rectangle:
  pop de
  ; Get height
  ld a, [de]
  swap a
  and 15
  inc a
  ld b, a
  ; Get width
  ld a, [de]
  and 15
  inc a
  ld c, a

  ; Update level pointer
  inc de
  push de
  call .get_single_block_list
.rectloop_row:
  push hl
  ld d, c
.rectloop:
  ld [hl+], a
  dec d
  jr nz, .rectloop
  pop hl
  ; Move down a row
  ld de, 16
  add hl, de
  dec b
  jr nz, .rectloop_row

  jr .done
; ----------------------------------
.single:
  call .get_single_block_list
  ld [hl], a
  ; falls into .done
.done:
  pop de
  jp DecompressMapLoop

.exit:
  pop de

  ; Get position of last instruction
  ; to get player starting position
  ldh a, [temp+1]
  and 15
  ldh [PlayerPXH], a
  ldh a, [temp+1]
  swap a
  and 15
  ldh [PlayerPYH], a
  xor a
  ldh [PlayerPXL], a
  ldh [PlayerPYL], a
  ret

.get_multi_count:
  ldh a, [temp]
  and 15
  ld c, a
  inc c
  ret

; A = block to use (single or fill)
.get_single_block_list:
  push hl
  ld hl, SingleBlockList
  ldh a, [temp+0]
  and 15
  add_hl_a
  ld a, [hl]
  pop hl
  ret

; A = block to use
.get_multi_block_list:
  push hl
  ld hl, MultiBlockList-2 ; add the 2 back
  ldh a, [temp+0]
  swap a
  and 15
  add_hl_a  
  ld a, [hl]
  pop hl
  ret
